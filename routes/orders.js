const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { body, validationResult } = require('express-validator');
const multer = require('multer');
const supabase = require('../supabaseClient');
const axios = require('axios');

const router = express.Router();
const prisma = new PrismaClient();
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;

const storage = multer.memoryStorage();
const upload = multer({ storage });
const ADMIN_IDS = ['6970790362', '5505526221'];
async function notifyAdmins(order, username) {
  const message = `
ğŸ“¦ <b>ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ·Ğ°ĞºĞ°Ğ· ÑĞ¾Ğ·Ğ´Ğ°Ğ½!</b>
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ†” <b>ID Ğ·Ğ°ĞºĞ°Ğ·Ğ°:</b> ${order.id}
ğŸ‘¤ <b>ĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ:</b> ${order.firstName + `(@${username})` || 'ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚ĞµĞ½'}
ğŸ“— <b>Ğ¢Ğ¸Ğ¿:</b> ${order.orderType}
ğŸ’° <b>Ğ¡ÑƒĞ¼Ğ¼Ğ°:</b> ${order.totalAmount} USD
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš™ï¸ ĞŸĞµÑ€ĞµĞ¹Ğ´Ğ¸ Ğ² Ğ°Ğ´Ğ¼Ğ¸Ğ½ĞºÑƒ Ğ´Ğ»Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¸.
  `;

  for (const adminId of ADMIN_IDS) {
    try {
      await axios.post(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
        chat_id: adminId,
        text: message,
        parse_mode: 'HTML',
      });
    } catch (err) {
      console.error(`âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞµ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ°Ğ´Ğ¼Ğ¸Ğ½Ñƒ ${adminId}:`, err.response?.data || err.message);
    }
  }
}

router.post("/stars", async (req, res) => {
  const { title, description, amount, userId } = req.body;

  console.log('ğŸŒŸ === STARS PAYMENT REQUEST ===');
  console.log('ğŸ“¥ Request body:', { title, description, amount, userId });

  if (!userId) {
    console.log('âŒ UserId not provided');
    return res.status(400).json({ error: "UserId is required" });
  }

  try {
    // 1. ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ Ğ¸Ğ»Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    console.log('ğŸ” Looking for user with telegramId:', userId);
    let user = await prisma.user.findUnique({ where: { telegramId: userId } });
    
    if (!user) {
      console.log('â• User not found, creating new user...');
      user = await prisma.user.create({ data: { telegramId: userId } });
      console.log('âœ… New user created:', { id: user.id, telegramId: user.telegramId });
    } else {
      console.log('âœ… User found:', { id: user.id, telegramId: user.telegramId });
    }

    // 2. Ğ¡ĞĞĞ§ĞĞ›Ğ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ·Ğ°ĞºĞ°Ğ·
    console.log('ğŸ“¦ Creating order...');
    const order = await prisma.order.create({
      data: {
        userId: user.id,
        telegramId: userId,
        orderType: "RATING",
        paymentMethod: "STARS",
        totalAmount: amount,
        status: "PENDING",
        paymentStatus: "PENDING",
      },
    });
    console.log('âœ… Order created:', {
      orderId: order.id,
      userId: order.userId,
      telegramId: order.telegramId,
      amount: order.totalAmount,
      status: order.status,
      paymentStatus: order.paymentStatus
    });

    // 3. ĞŸĞĞ¢ĞĞœ ÑĞ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ invoice Ñ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¼ orderId
    const invoicePayload = { orderId: order.id };
    console.log('ğŸ’³ Creating Telegram invoice...');
    console.log('ğŸ“‹ Invoice payload:', invoicePayload);
    
    const response = await fetch(
      `https://api.telegram.org/bot${BOT_TOKEN}/createInvoiceLink`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          title,
          description,
          payload: JSON.stringify(invoicePayload),
          currency: "XTR",
          prices: [{ label: title, amount: Math.round(amount) }],
        }),
      }
    );

    const data = await response.json();
    console.log('ğŸ“¨ Telegram API response:', data);
    
    if (!data.ok) {
      console.error('âŒ Failed to create invoice:', data.description);
      console.log('ğŸ—‘ï¸ Deleting order:', order.id);
      await prisma.order.delete({ where: { id: order.id } });
      return res.status(400).json({ error: data.description });
    }

    console.log('âœ… Invoice created successfully:', data.result);
    console.log('ğŸ‰ === STARS PAYMENT REQUEST COMPLETED ===\n');
    
    res.json({ invoice_url: data.result, orderId: order.id });
  } catch (err) {
    console.error('âŒ Error in /stars endpoint:', err);
    console.error('Stack trace:', err.stack);
    res.status(500).json({ error: "ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğ¸ ÑÑ‡Ñ‘Ñ‚Ğ°" });
  }
});

// POST /api/orders - ÑĞ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·
router.post('/', [
  body('userId').notEmpty().withMessage('User ID is required'),
  body('orderType').isIn(['PRODUCT', 'BUNDLE', 'VIP', 'CUSTOM_VIDEO', 'VIDEO_CALL', 'RATING']).withMessage('Invalid order type'),
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const {
      userId,
      orderType,
      items,
      firstName,
      telegramId,
      username,
      paymentMethod,
      lastName,
      address,
      city,
      zipCode,
      country
    } = req.body;

    // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
    let user = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!user) {
      user = await prisma.user.create({
        data: { id: userId, telegramId: telegramId }
      });
    }

    let totalAmount = 0;
    const orderItems = [];

    // ĞĞ±Ñ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ Ñ€Ğ°Ğ·Ğ»Ğ¸Ñ‡Ğ½Ñ‹Ğµ Ñ‚Ğ¸Ğ¿Ñ‹ Ğ·Ğ°ĞºĞ°Ğ·Ğ¾Ğ²
    if (orderType === 'PRODUCT' || orderType === 'BUNDLE') {
      for (const item of items || []) {
        if (item.type === 'product') {
          const product = await prisma.product.findUnique({
            where: { id: item.id }
          });
          if (product) {
            totalAmount += product.price * (item.quantity || 1);
            orderItems.push({
              productId: product.id,
              quantity: item.quantity || 1,
              price: product.price
            });
          }
        } else if (item.type === 'bundle') {
          const bundle = await prisma.bundle.findUnique({
            where: { id: item.id }
          });
          if (bundle) {
            totalAmount += bundle.price;
            orderItems.push({
              bundleId: bundle.id,
              quantity: 1,
              price: bundle.price
            });
          }
        }
      }
    } else if (orderType === 'VIP') {
      totalAmount = 49.99;
    } else if (orderType === 'CUSTOM_VIDEO') {
      totalAmount = 99.99;
    } else if (orderType === 'VIDEO_CALL') {
      totalAmount = 149.99;
    } else if (orderType === 'RATING') {
      totalAmount = 19.99;
    }

    // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°ĞºĞ°Ğ·
    const order = await prisma.order.create({
      data: {
        userId: user.id,
        telegramId: user.telegramId,
        orderType,
        totalAmount,
        firstName,
        lastName,
        address,
        paymentMethod,
        username,
        city,
        zipCode,
        country,
        orderItems: {
          create: orderItems
        }
      },
      include: {
        orderItems: {
          include: {
            product: true,
            bundle: true
          }
        }
      }
    });
    await notifyAdmins(order, username);
    res.status(201).json(order);
  } catch (error) {
    console.error('Error creating order:', error);
    res.status(500).json({ error: 'Failed to create order' });
  }
});

// PATCH /api/orders/:id â€” Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ¸Ñ‚ÑŒ ÑĞºÑ€Ğ¸Ğ½ÑˆĞ¾Ñ‚
router.patch('/:id-rating', upload.single('rating'), async (req, res) => {
  try {
    const { id } = req.params;
    const existingOrder = await prisma.order.findUnique({ where: { id } });

    if (!existingOrder) {
      return res.status(404).json({ error: 'Order not found' });
    }

    if (!req.file) {
      return res.status(400).json({ error: 'rating file is required' });
    }

    // ... Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ´ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ² Supabase ĞºĞ°Ğº Ñƒ Ñ‚ĞµĞ±Ñ ...
    const fileExt = req.file.originalname.split('.').pop();
    const fileName = `orders/${Date.now()}-${Math.random()
      .toString(36)
      .substring(7)}.${fileExt}`;

    const { data, error: uploadError } = await supabase.storage
      .from(process.env.SUPABASE_BUCKET)
      .upload(fileName, req.file.buffer, {
        contentType: req.file.mimetype,
        upsert: false,
      });

    if (uploadError) {
      console.error('Supabase upload error:', uploadError);
      return res.status(500).json({ error: 'Failed to upload rating' });
    }

    const { data: publicUrlData } = supabase.storage
      .from(process.env.SUPABASE_BUCKET)
      .getPublicUrl(fileName);

    const ratingUrl = publicUrlData.publicUrl;

    const updatedOrder = await prisma.order.update({
      where: { id },
      data: { rating: ratingUrl, updatedAt: new Date() },
      include: { user: true, orderItems: { include: { product: true, bundle: true } } },
    });

    res.json(updatedOrder);
  } catch (err) {
    console.error('Error updating order rating:', err);
    res.status(500).json({ error: 'Failed to update order rating' });
  }
});

// PATCH /api/orders/:id â€” Ğ¿Ñ€Ğ¸ĞºÑ€ĞµĞ¿Ğ¸Ñ‚ÑŒ ÑĞºÑ€Ğ¸Ğ½ÑˆĞ¾Ñ‚
router.patch('/:id', upload.single('screenshot'), async (req, res) => {
  try {
    const { id } = req.params;
    const existingOrder = await prisma.order.findUnique({ where: { id } });

    if (!existingOrder) {
      return res.status(404).json({ error: 'Order not found' });
    }

    if (!req.file) {
      return res.status(400).json({ error: 'Screenshot file is required' });
    }

    // ... Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ğ¾Ğ¹ ĞºĞ¾Ğ´ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ Ğ² Supabase ĞºĞ°Ğº Ñƒ Ñ‚ĞµĞ±Ñ ...
    const fileExt = req.file.originalname.split('.').pop();
    const fileName = `orders/${Date.now()}-${Math.random()
      .toString(36)
      .substring(7)}.${fileExt}`;

    const { data, error: uploadError } = await supabase.storage
      .from(process.env.SUPABASE_BUCKET)
      .upload(fileName, req.file.buffer, {
        contentType: req.file.mimetype,
        upsert: false,
      });

    if (uploadError) {
      console.error('Supabase upload error:', uploadError);
      return res.status(500).json({ error: 'Failed to upload screenshot' });
    }

    const { data: publicUrlData } = supabase.storage
      .from(process.env.SUPABASE_BUCKET)
      .getPublicUrl(fileName);

    const screenshotUrl = publicUrlData.publicUrl;

    const updatedOrder = await prisma.order.update({
      where: { id },
      data: { screenshot: screenshotUrl, updatedAt: new Date() },
      include: { user: true, orderItems: { include: { product: true, bundle: true } } },
    });

    res.json(updatedOrder);
  } catch (err) {
    console.error('Error updating order screenshot:', err);
    res.status(500).json({ error: 'Failed to update order screenshot' });
  }
});

// PATCH /api/orders/:id/payment-status - Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ¿Ğ»Ğ°Ñ‚ĞµĞ¶Ğ°
router.patch('/:id/payment-status', [
  body('paymentStatus').isIn(['PENDING', 'AWAITING_CHECK', 'CONFIRMED', 'FAILED'])
    .withMessage('Invalid payment status'),
], async (req, res) => {
  try {
    const { id } = req.params;
    const { paymentStatus } = req.body;

    const order = await prisma.order.update({
      where: { id },
      data: { paymentStatus, updatedAt: new Date() },
      include: {
        orderItems: {
          include: { product: true, bundle: true },
        },
      },
    });

    res.json(order);
  } catch (error) {
    console.error('Error updating payment status:', error);
    res.status(500).json({ error: 'Failed to update payment status' });
  }
});

// PATCH /api/orders/:id/status - Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
// PATCH /api/orders/:id/status - Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
router.patch('/:id/status', async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    // Ğ’Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ° Ğ·Ğ°ĞºĞ°Ğ·Ğ°
    const validStatuses = ['PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        error: 'Invalid order status',
        validStatuses: validStatuses
      });
    }

    // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°, ĞĞ• Ñ‚Ñ€Ğ¾Ğ³Ğ°Ñ paymentStatus
    const updatedOrder = await prisma.order.update({
      where: { id },
      data: {
        status,  // Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ ÑÑ‚Ğ°Ñ‚ÑƒÑ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
        updatedAt: new Date()
      },
      include: {
        user: true,
        orderItems: {
          include: {
            product: true,
            bundle: true
          }
        }
      }
    });

    res.json(updatedOrder);
  } catch (error) {
    console.error('Error updating order status:', error);
    res.status(500).json({ error: 'Failed to update order status' });
  }
});

// GET /api/orders/:userId - Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ°ĞºĞ°Ğ·Ñ‹ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ
router.get('/:userId', async (req, res) => {
  try {
    const { userId } = req.params;

    const user = await prisma.user.findUnique({
      where: { telegramId: userId }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const orders = await prisma.order.findMany({
      where: { userId: user.id },
      include: {
        orderItems: {
          include: {
            product: true,
            bundle: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(orders);
  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

// GET /api/orders/detail/:id - Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ´ĞµÑ‚Ğ°Ğ»Ğ¸ Ğ·Ğ°ĞºĞ°Ğ·Ğ°
router.get('/detail/:id', async (req, res) => {
  try {
    const { id } = req.params;

    const order = await prisma.order.findUnique({
      where: { id },
      include: {
        user: true,
        orderItems: {
          include: {
            product: true,
            bundle: true
          }
        }
      }
    });

    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }

    res.json(order);
  } catch (error) {
    console.error('Error fetching order:', error);
    res.status(500).json({ error: 'Failed to fetch order' });
  }
});

module.exports = router;
